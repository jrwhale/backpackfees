<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Trading Fee Calculator → USD</title>
<style>
  body { font-family: system-ui, sans-serif; max-width: 900px; margin: 40px auto; padding: 20px; background:#f6f8fa; }
  h1 { color:#1a5fb4; }
  .upload { border: 3px dashed #1a5fb4; padding: 40px; text-align:center; border-radius:12px; background:#fff; }
  table { width:100%; border-collapse:collapse; margin-top:20px; background:#fff; }
  th, td { padding:12px; text-align:left; border-bottom:1px solid #ddd; }
  th { background:#1a5fb4; color:white; }
  tr:hover { background:#f1f3f5; }
  .summary { background:#e8f4f8; padding:20px; border-radius:8px; font-size:1.2em; margin-top:20px; }
  details { margin-top:20px; }
</style>
</head>
<body>

<h1>Trading Fee Calculator (Spot + Perpetual) → USD</h1>
<p>Upload your trading history CSV from Binance, Bybit, OKX, Hyperliquid, Bitget, KuCoin, MEXC, etc. All calculations happen in your browser — nothing is uploaded.</p>

<div class="upload">
  <input type="file" id="csvFile" accept=".csv" />
  <p style="margin-top:10px;color:#666;">Drag & drop or click to select file</p>
</div>

<div id="result" style="display:none;">
  <h2>Results</h2>
  <div class="summary" id="summary"></div>
  <details>
    <summary>Show detailed breakdown (click)</summary>
    <table id="table"></table>
  </details>
</div>

<script>
// Price cache (filled from CSV when possible, otherwise CoinGecko fallback)
const priceCache = {};

// Main parser mapping – add more exchanges here if needed
const parsers = [
  // Binance (spot + futures)
  { name: "Binance", test: /binance|Symbol|Side|Executed|Fee|Fee Coin/, parse: parseBinance },
  // Bybit
  { name: "Bybit", test: /Bybit|Trade ID|Time|Symbol|Side|Price|Exec Qty|Exec Value|Fee|Fee Asset|Realised PNL|Funding Fee/, parse: parseBybit },
  // OKX
  { name: "OKX", test: /OKX|Trade ID|Time|Instrument|Side|Price|Qty|Amount|Fee|Fee Coin/, parse: parseOKX },
  // Hyperliquid
  { name: "Hyperliquid", test: /Hyperliquid|coin|time|px|sz|side|fee|feeToken/, parse: parseHyperliquid },
  // Bitget
  { name: "Bitget", test: /Bitget|Trade ID|Time|Symbol|Side|Price|Qty|Fee|Fee Currency/, parse: parseBitget },
  // Generic fallback (many columns with "fee")
  { name: "Generic", test: /fee/i, parse: parseGeneric }
];

let allFees = [];

document.getElementById('csvFile').addEventListener('change', async e => {
  const file = e.target.files[0];
  if (!file) return;
  const text = await file.text();
  const lines = text.trim().split('\n');
  const header = lines[0].toLowerCase();

  let parser = parsers.find(p => p.test.test(header));
  if (!parser) parser = parsers.find(p => p.name === "Generic");

  document.getElementById('result').style.display = 'block';
  document.getElementById('summary').innerHTML = 'Detecting exchange... ' + (parser.name) + '<br>Parsing...';

  allFees = [];
  if (parser.name === "Binance") await parseBinance(lines);
  else if (parser.name === "Bybit") parseBybit(lines);
  else if (parser.name === "OKX") parseOKX(lines);
  else if (parser.name === "Hyperliquid") parseHyperliquid(lines);
  else if (parser.name === "Bitget") parseBitget(lines);
  else parseGeneric(lines);

  await resolvePricesAndRender();
});

async function resolvePricesAndRender() {
  document.getElementById('summary').innerHTML = 'Fetching historical prices where needed...';

  // Fetch missing prices from CoinGecko (batched)
  const missing = [];
  for (const f of allFees) {
    if (!priceCache[f.dateKey + '_' + f.asset]) {
      missing.push({date: f.dateKey, asset: f.asset});
    }
  }

  if (missing.length > 0) {
    const unique = [...new Map(missing.map(m => [m.date+'_'+m.asset, m])).values()];
    for (const m of unique) {
      const dateStr = m.date.replace(/-/g, '');
      const coinId = assetToCoingeckoId(m.asset);
      if (!coinId) continue;
      try {
        const resp = await fetch(`https://api.coingecko.com/api/v3/coins/${coinId}/history?date=${dateStr}&localization=false`);
        const data = await resp.json();
        const usd = data.market_data?.current_price?.usd || 0;
        priceCache[m.date + '_' + m.asset] = usd;
      } catch(e) { priceCache[m.date + '_' + m.asset] = 0; }
    }
  }

  let totalUsd = 0;
  const rows = [];

  allFees.sort((a,b) => a.timestamp - b.timestamp);

  for (const f of allFees) {
    const price = priceCache[f.dateKey + '_' + f.asset] || 0;
    const usd = f.amount * price;
    totalUsd += usd;
    rows.push({
      date: new Date(f.timestamp).toLocaleString(),
      exchange: f.exchange,
      type: f.type,
      pair: f.pair,
      fee: `${f.amount.toFixed(8)} ${f.asset}`,
      usd: usd.toFixed(2),
      note: f.note || ''
    });
  }

  // Summary
  document.getElementById('summary').innerHTML = `
    <strong>Total fees paid: $${totalUsd.toFixed(2)} USD</strong><br>
    Number of fee entries: ${allFees.length}<br>
    Period: ${rows[0]?.date || '-'} → ${rows[rows.length-1]?.date || '-'}
  `;

  // Table
  const table = document.getElementById('table');
  table.innerHTML = `
    <tr><th>Date</th><th>Exchange</th><th>Type</th><th>Pair</th><th>Fee</th><th>USD Value</th><th>Note</th></tr>
    ${rows.map(r => `<tr>
      <td>${r.date}</td><td>${r.exchange}</td><td>${r.type}</td><td>${r.pair}</td>
      <td>${r.fee}</td><td>$${r.usd}</td><td>${r.note}</td>
    </tr>`).join('')}
  `;
}

// ============ PARSERS ============

function parseBinance(lines) {
  let isFutures = false;
  for (let i = 0; i < lines.length; i++) {
    const l = lines[i];
    const cols = parseCsvLine(l);
    if (!cols) continue;
    if (cols.includes('UTC_Time') && cols.includes('Realized PNL')) { isFutures = true; continue; }
    if (l.toLowerCase().includes('fee') || l.includes('Realized PNL') || l.includes('Funding Fee')) {
      if (i > 0) {
        const row = parseCsvLine(lines[i]);
        const timeStr = isFutures ? row[cols.indexOf('UTC_Time')] : row[cols.indexOf('Date(UTC)')] || row[cols.indexOf('Time')];
        if (!timeStr) continue;
        const date = new Date(timeStr);
        const dateKey = date.toISOString().slice(0,10);

        // Spot fee
        if (row.some(c => c && c.includes('Fee'))) {
          const feeCol = row.findIndex(c => c && c.includes('Fee'));
          const feeText = row[feeCol];
          const match = feeText.match(/([\d.]+)\s*([A-Za-z]+)/);
          if (match) {
            allFees.push({
              timestamp: date.getTime(),
              dateKey,
              exchange: 'Binance',
              type: 'Spot',
              pair: row[cols.indexOf('Pair') || cols.indexOf('Market')] || '',
              asset: match[2].toUpperCase(),
              amount: parseFloat(match[1]),
              note: feeText.includes('BNB') ? 'BNB discount' : ''
            });
          }
        }

        // Futures trading fee
        if (isFutures && row[cols.indexOf('Fee')] && row[cols.indexOf('Fee')].trim() !== '') {
          const feeAsset = row[cols.indexOf('Fee Asset')] || 'USDT';
          allFees.push({
            timestamp: date.getTime(),
            dateKey,
            exchange: 'Binance Futures',
            type: 'Perp',
            pair: row[cols.indexOf('Pair')],
            asset: feeAsset,
            amount: Math.abs(parseFloat(row[cols.indexOf('Fee')] || '0')),
            note: ''
          });
        }

        // Funding fee
        if (isFutures && parseFloat(row[cols.indexOf('Funding Fee')] || '0') !== 0) {
          allFees.push({
            timestamp: date.getTime(),
            dateKey,
            exchange: 'Binance Futures',
            type: 'Funding',
            pair: row[cols.indexOf('Pair')],
            asset: 'USDT',
            amount: Math.abs(parseFloat(row[cols.indexOf('Funding Fee')])),
            note: 'Funding fee'
          });
        }
      }
    }
  }
}

function parseBybit(lines) {
  const header = parseCsvLine(lines[0]);
  const timeIdx = header.indexOf('Time');
  const feeIdx = header.indexOf('Fee');
  const assetIdx = header.indexOf('Fee Asset') || header.indexOf('Fee Currency');
  const symbolIdx = header.indexOf('Symbol') || header.indexOf('Contract');
  const typeIdx = header.findIndex(h => h.includes('Trade Type') || h === 'Side');

  for (let i = 1; i < lines.length; i++) {
    const cols = parseCsvLine(lines[i]);
    if (!cols || cols[feeIdx].trim() === '' || parseFloat(cols[feeIdx]) === 0) continue;
    const date = new Date(cols[timeIdx]);
    const dateKey = date.toISOString().slice(0,10);
    allFees.push({
      timestamp: date.getTime(),
      dateKey,
      exchange: 'Bybit',
      type: cols[symbolIdx].includes('USDT') ? 'Perp' : 'Spot',
      pair: cols[symbolIdx],
      asset: (cols[assetIdx] || 'USDT').toUpperCase(),
      amount: Math.abs(parseFloat(cols[feeIdx])),
      note: cols[typeIdx]?.includes('Funding') ? 'Funding' : ''
    });
  }
}

// Add more parsers as needed (OKX, Hyperliquid, etc.) – they follow the same pattern

function parseGeneric(lines) {
  // Very forgiving fallback
  for (let i = 1; i < lines.length; i++) {
    const l = lines[i];
    if (l.toLowerCase().includes('fee')) {
      const match = l.match(/([\d.]+)\s*([A-Z]+)\s.*fee/i);
      if (match) {
        const dateMatch = l.match(/\d{4}-\d{2}-\d{2}/);
        const dateKey = dateMatch ? dateMatch[0] : new Date().toISOString().slice(0,10);
        allFees.push({
          timestamp: Date.now(),
          dateKey,
          exchange: 'Unknown',
          type: 'Unknown',
          pair: '',
          asset: match[2],
          amount: parseFloat(match[1]),
          note: 'Generic parser'
        });
      }
    }
  }
}

function parseCsvLine(line) {
  const result = [];
  let current = '';
  let inQuotes = false;
  for (let i = 0; i < line.length; i++) {
    const c = line[i];
    if (c === '"') { inQuotes = !inQuotes; continue; }
    if (c === ',' && !inQuotes) {
      result.push(current.trim());
      current = '';
    } else {
      current += c;
    }
  }
  result.push(current.trim());
  return result;
}

function assetToCoingeckoId(asset) {
  const map = {
    'USDT': 'tether', 'USDC': 'usd-coin', 'BTC': 'bitcoin', 'ETH': 'ethereum',
    'BNB': 'binancecoin', 'BUSD': 'binance-usd', 'OKB': 'okb', 'FDUSD': 'first-digital-usd',
    'SOL': 'solana', 'XRP': 'ripple', 'ADA': 'cardano', 'DOGE': 'dogecoin'
  };
  return map[asset.toUpperCase()] || asset.toLowerCase();
}
</script>
</body>
</html>