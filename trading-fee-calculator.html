<script>
// Price cache
const priceCache = {};

const parsers = [ /* ... same as before ... */ ];

// ... keep your parsers exactly the same ...

document.getElementById('csvFile').addEventListener('change', async e => {
  const file = e.target.files[0];
  if (!file) return;
  const text = await file.text();
  const lines = text.trim().split('\n');
  const header = lines[0].toLowerCase();

  let parser = parsers.find(p => p.test.test(header)) || parsers.find(p => p.name === "Generic");

  document.getElementById('result').style.display = 'block';
  document.getElementById('summary').innerHTML = `Detected: ${parser.name}<br>Parsing trades...`;

  allFees = [];
  // call the correct parser (unchanged)
  if (parser.name === "Binance") await parseBinance(lines);
  else if (parser.name === "Bybit") parseBybit(lines);
  else if (parser.name === "OKX") parseOKX(lines);
  else if (parser.name === "Hyperliquid") parseHyperliquid(lines);
  else if (parser.name === "Bitget") parseBitget(lines);
  else parseGeneric(lines);

  await resolvePricesAndRender();
});

async function resolvePricesAndRender() {
  document.getElementById('summary').innerHTML = 'Resolving historical prices (this can take 10–30 sec)...';

  const missing = new Set();
  for (const f of allFees) {
    const key = `${f.dateKey}_${f.asset}`;
    if (!priceCache[key]) missing.add(key);
  }

  // Batch + proper headers + delay
  for (const key of missing) {
    const [dateKey, asset] = key.split('_');
    const coinId = assetToCoingeckoId(asset);
    if (!coinId) continue;

    const dateStr = dateKey.replace(/-/g, ''); // YYYYMMDD format
    try {
      const resp = await fetch(`https://api.coingecko.com/api/v3/coins/${coinId}/history?date=${dateStr}&localization=false`, {
        headers: {
          'User-Agent': 'TradingFeeCalculator/1.0 (+https://yourdomain.com)', // change if you have a domain
          'Accept': 'application/json',
          'Origin': location.origin,
          'Referer': location.origin + '/'
        }
      });

      if (resp.ok) {
        const data = await resp.json();
        const usd = data.market_data?.current_price?.usd ?? 0;
        priceCache[key] = usd;
      } else {
        priceCache[key] = 0;
      }
    } catch (e) {
      priceCache[key] = 0;
    }

    // Be nice to CoinGecko — max ~50 requests/minute
    await new Promise(r => setTimeout(r, 1200));
  }

  // Now render results
  let totalUsd = 0;
  const rows = [];

  allFees.sort((a, b) => a.timestamp - b.timestamp);

  for (const f of allFees) {
    const usdPrice = priceCache[`${f.dateKey}_${f.asset}`] || 0;
    const usdValue = f.amount * usdPrice;
    totalUsd += usdValue;

    rows.push({
      date: new Date(f.timestamp).toLocaleString(),
      exchange: f.exchange || 'Unknown',
      type: f.type || 'Trade',
      pair: f.pair || '',
      fee: `${f.amount.toFixed(8)} ${f.asset}`,
      usd: usdValue.toFixed(2),
      note: f.note || ''
    });
  }

  document.getElementById('summary').innerHTML = `
    <strong>Total trading fees paid: $${totalUsd.toFixed(2)} USD</strong><br>
    Number of fee entries: ${allFees.length}<br>
    Period: ${rows[0]?.date || '-'} → ${rows[rows.length-1]?.date || '-'}
    ${missing.size > 0 ? `<br><small>Prices fetched for ${missing.size} asset-date pairs</small>` : ''}
  `;

  const table = document.getElementById('table');
  table.innerHTML = `<tr><th>Date</th><th>Exchange</th><th>Type</th><th>Pair</th><th>Fee</th><th>USD Value</th><th>Note</th></tr>` +
    rows.map(r => `<tr>
      <td>${r.date}</td><td>${r.exchange}</td><td>${r.type}</td><td>${r.pair}</td>
      <td>${r.fee}</td><td>$${r.usd}</td><td>${r.note}</td>
    </tr>`).join('');
}

// Keep all your existing parsers (parseBinance, parseBybit, etc.) unchanged
// and the assetToCoingeckoId + parseCsvLine functions exactly as before
</script>